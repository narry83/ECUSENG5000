import java.util.Iterator;/**   A class that implements the ADT binary search tree by extending BinaryTree.   Recursive version.      @author Frank M. Carrano   @author Timothy M. Henry   @version 4.0*/public class _09BinarySearchTree<T extends Comparable<? super T>>             extends _08BinaryTree<T>              implements _03SearchTreeInterface<T>{   public _09BinarySearchTree()   {      super();   } // end default constructor   public _09BinarySearchTree(T rootEntry)   {      super();      setRootNode(new _01BinaryNode<>(rootEntry));   } // end constructor   //.................................................      public void setTree(T rootData) // Disable setTree (see Segment 25.6)   {      throw new UnsupportedOperationException();   } // end setTree //.................................................      public void setTree(T rootData, _04BinaryTreeInterface<T> leftTree,                                    _04BinaryTreeInterface<T> rightTree)   {      throw new UnsupportedOperationException();   } // end setTree  	public T getEntry(T entry)	{	   return findEntry(getRootNode(), entry);	} // end getEntry	//.................................................	   // Recursively finds the given entry in the binary tree rooted at the given node.	private T findEntry(_01BinaryNode<T> rootNode, T entry)	{	      T result = null;      if (rootNode != null)      {         T rootEntry = rootNode.getData();         if (entry.equals(rootEntry))            result = rootEntry;         else if (entry.compareTo(rootEntry) < 0)            result = findEntry(rootNode.getLeftChild(), entry);         else            result = findEntry(rootNode.getRightChild(), entry);      } // end if      return result;	} // end findEntry		public boolean contains(T entry)	{		return getEntry(entry) != null;	} // end contains		//.................................................	   public T add(T newEntry)   {      T result = null;      if (isEmpty())         setRootNode(new _01BinaryNode<>(newEntry));      else         result = addEntry(getRootNode(), newEntry);             return result;   } // end add   // Adds newEntry to the nonempty subtree rooted at rootNode.   private T addEntry(_01BinaryNode<T> rootNode, T newEntry)   {      assert rootNode != null;      T result = null;      int comparison = newEntry.compareTo(rootNode.getData());      if (comparison == 0)      {         result = rootNode.getData();         rootNode.setData(newEntry);      }      else if (comparison < 0)      {         if (rootNode.hasLeftChild())            result = addEntry(rootNode.getLeftChild(), newEntry);         else            rootNode.setLeftChild(new _01BinaryNode<>(newEntry));      }      else      {         assert comparison > 0;         if (rootNode.hasRightChild())            result = addEntry(rootNode.getRightChild(), newEntry);         else            rootNode.setRightChild(new _01BinaryNode<>(newEntry));      } // end if      return result;   } // end addEntry	public T remove(T entry)   {      ReturnObject oldEntry = new ReturnObject(null);      _01BinaryNode<T> newRoot = removeEntry(getRootNode(), entry, oldEntry);      setRootNode(newRoot);      return oldEntry.get();   } // end remove		//.................................................		// Removes an entry from the tree rooted at a given node.   // Parameters:   //    rootNode  A reference to the root of a tree.   //    entry  The object to be removed.   //    oldEntry  An object whose data field is null.   // Returns:  The root node of the resulting tree; if entry matches   //           an entry in the tree, oldEntry's data field is the entry   //           that was removed from the tree; otherwise it is null.   private _01BinaryNode<T> removeEntry(_01BinaryNode<T> rootNode, T entry,                                     ReturnObject oldEntry)   {      if (rootNode != null)      {         T rootData = rootNode.getData();         int comparison = entry.compareTo(rootData);         if (comparison == 0)       // entry == root entry         {            oldEntry.set(rootData);            rootNode = removeFromRoot(rootNode);         }         else if (comparison < 0)   // entry < root entry         {            _01BinaryNode<T> leftChild = rootNode.getLeftChild();            _01BinaryNode<T> subtreeRoot = removeEntry(leftChild, entry, oldEntry);            rootNode.setLeftChild(subtreeRoot);         }         else                       // entry > root entry         {            _01BinaryNode<T> rightChild = rootNode.getRightChild();            rootNode.setRightChild(removeEntry(rightChild, entry, oldEntry));         } // end if      } // end if      return rootNode;   } // end removeEntry //.................................................   	// Removes the entry in a given root node of a subtree.   // Parameter:   //    rootNode  A reference to the root of the subtree.   // Returns:  The root node of the revised subtree.   private _01BinaryNode<T> removeFromRoot(_01BinaryNode<T> rootNode)   {      // Case 1: rootNode has two children       if (rootNode.hasLeftChild() && rootNode.hasRightChild())      {         // Find node with largest entry in left subtree         _01BinaryNode<T> leftSubtreeRoot = rootNode.getLeftChild();         _01BinaryNode<T> largestNode = findLargest(leftSubtreeRoot);         // Replace entry in root         rootNode.setData(largestNode.getData());         // Remove node with largest entry in left subtree         rootNode.setLeftChild(removeLargest(leftSubtreeRoot));      } // end if       // Case 2: rootNode has at most one child      else if (rootNode.hasRightChild())         rootNode = rootNode.getRightChild();      else         rootNode = rootNode.getLeftChild();             // Assertion: If rootNode was a leaf, it is now null      return rootNode;    } // end removeEntry //.................................................      // Finds the node containing the largest entry in a given tree.   // Parameter:   //    rootNode  A reference to the root node of the tree.   // Returns:  The node containing the largest entry in the tree.   private _01BinaryNode<T> findLargest(_01BinaryNode<T> rootNode)   {      if (rootNode.hasRightChild())         rootNode = findLargest(rootNode.getRightChild());             return rootNode;   } // end findLargest	// Removes the node containing the largest entry in a given tree.   // Parameter:   //    rootNode  A reference to the root node of the tree.   // Returns:  The root node of the revised tree.   private _01BinaryNode<T> removeLargest(_01BinaryNode<T> rootNode)   {      if (rootNode.hasRightChild())      {         _01BinaryNode<T> rightChild = rootNode.getRightChild();         rightChild = removeLargest(rightChild);         rootNode.setRightChild(rightChild);      }      else          rootNode = rootNode.getLeftChild();             return rootNode;   } // end removeLargest	private class ReturnObject	{		private T item;					private ReturnObject(T entry)		{			item = entry;		} // end constructor				public T get()		{			return item;		} // end get		public void set(T entry)		{			item = entry;		} // end set	} // end ReturnObject} // end BinarySearchTree